SECTION 3 ‚Äî UNIX SYSTEM PROGRAMMING (IN C)

We will go step-by-step in this order:

1Ô∏è‚É£ Process Creation (fork, exec, wait)
2Ô∏è‚É£ Signals (signal, sigaction, kill, alarm)
3Ô∏è‚É£ Inter-Process Communication (Shared Memory, Message Queues, Semaphores)
4Ô∏è‚É£ Sockets (TCP/UDP, client‚Äìserver)
5Ô∏è‚É£ Multi-threading (pthreads)
6Ô∏è‚É£ Pipes (unnamed + named/FIFO)


‚ÄúUNIX commands are programs written in C that interact with the UNIX environment using system calls.‚Äù
This means:

Almost every command you run in the terminal (ls, cd, cat, rm, etc.)
Is actually a C program
And that C program interacts with the UNIX kernel using system calls.

Examples:
  
  open() ‚Üí ask kernel to open a file
  read() ‚Üí ask kernel to read data
  write() ‚Üí ask kernel to write data
  fork() ‚Üí ask kernel to create a new process
  exec() ‚Üí ask kernel to load another program
  getpid() ‚Üí ask kernel to tell PID

System Calls ‚â† Library Functions
This is very important.

What is a System Call?

A system call is how a user program (written in C) talks to the Unix kernel.

C Program (User)  --->  System Call  --->  Kernel (OS)

Why do we need system calls?
  
  Because the user program cannot directly access hardware.
  CPU protects everything using user mode ‚Üí kernel mode.
  
  So, if you want to:
      
      open a file
      create a process
      access memory
      communicate between processes
      handle signals
  You must call the OS through a system call.

Where the system files are stored 
/usr/include/sys/syscall.h

inside this file we will get 
#define SYS_exit        1
#define SYS_fork        2
#define SYS_read        3
#define SYS_write       4
#define SYS_open        5
#define SYS_close       6
...

These numbers are system call numbers.

Every system call has a unique ID.
This is how the kernel knows which service you are asking for.


Why do we have system call numbers?

Because in the kernel, system calls are accessed with:

mov $4, %eax      ; 4 = SYS_write
int $0x80         ; interrupt to kernel

Understanding errno in System Programming (UNIX/Linux)
What is errno?

errno is a global integer variable defined in the C Standard Library:
#include <errno.h>

It stores the error code of the last system call or library function that failed.

Important facts:

errno is not cleared on success ‚Üí it only changes when a system call fails.

So you must check the return value first, then check errno only if the return value indicates an error (usually -1).


Program 1: Using open(), read(), write(), close() + Error Handling

This program demonstrates:

‚úî Opening a file
‚úî Reading from a file
‚úî Writing its content to the terminal
‚úî Handling errors with errno, perror(), and strerror()

üìÅ File Name: file_read_demo.c


What is fork() in C?

    fork() is a system call in UNIX/Linux that creates a new process.
    
    The original process is called the parent.
    
    The newly created process is called the child.
    
    After calling fork(), both processes continue running the same code, but with different return values.


How fork() Works
‚û§ Syntax
pid_t pid = fork();

‚û§ Return Values

fork() returns:

Return value	Meaning
< 0	Fork failed (no child created)
0	Code running in the child process
> 0	Code running in the parent process (value is child's PID)

How Process Creation Happens

When fork() is called:

  The OS creates a copy of the parent process.
  
  Both processes have:
  
      Their own memory
      Their own stack
      Their own program counter
      Both continue execution from the same line after fork().
  
üí° Important

The parent and child run independently, so output order may vary.
