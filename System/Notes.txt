SECTION 3 — UNIX SYSTEM PROGRAMMING (IN C)

We will go step-by-step in this order:

1️⃣ Process Creation (fork, exec, wait)
2️⃣ Signals (signal, sigaction, kill, alarm)
3️⃣ Inter-Process Communication (Shared Memory, Message Queues, Semaphores)
4️⃣ Sockets (TCP/UDP, client–server)
5️⃣ Multi-threading (pthreads)
6️⃣ Pipes (unnamed + named/FIFO)


“UNIX commands are programs written in C that interact with the UNIX environment using system calls.”
This means:

Almost every command you run in the terminal (ls, cd, cat, rm, etc.)
Is actually a C program
And that C program interacts with the UNIX kernel using system calls.

Examples:
  
  open() → ask kernel to open a file
  read() → ask kernel to read data
  write() → ask kernel to write data
  fork() → ask kernel to create a new process
  exec() → ask kernel to load another program
  getpid() → ask kernel to tell PID

System Calls ≠ Library Functions
This is very important.

What is a System Call?

A system call is how a user program (written in C) talks to the Unix kernel.

C Program (User)  --->  System Call  --->  Kernel (OS)

Why do we need system calls?
  
  Because the user program cannot directly access hardware.
  CPU protects everything using user mode → kernel mode.
  
  So, if you want to:
      
      open a file
      create a process
      access memory
      communicate between processes
      handle signals
  You must call the OS through a system call.

Where the system files are stored 
/usr/include/sys/syscall.h

inside this file we will get 
#define SYS_exit        1
#define SYS_fork        2
#define SYS_read        3
#define SYS_write       4
#define SYS_open        5
#define SYS_close       6
...

